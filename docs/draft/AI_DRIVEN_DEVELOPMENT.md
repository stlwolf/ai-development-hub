# AI駆動開発フロー

> AIエディタとの協調による開発効率化の実践ガイド

## 概要

本ドキュメントは、AIエディタ（Cursor等）を活用した開発フローのノウハウをまとめたものです。
単なるコード補完ではなく、**AIをペアプログラミングパートナーとして活用**し、開発効率・品質を向上させることを目指します。

---

## 1. 基本原則

### 人間とAIの役割分担

| 人間が担当 | AIが担当 |
|-----------|---------|
| ビジネスロジックの定義 | 実装詳細の提案 |
| ドメイン知識の提供 | コード生成・修正 |
| 意思決定・判断 | 動作確認・検証 |
| コンテキストの提供 | パターン認識・適用 |

### コンテキスト共有の重要性

AIの出力品質は、**提供するコンテキストの質**に依存します。

```
❌ 悪い例：「ログイン機能を作って」
✅ 良い例：「CognitoのHosted UIを使ったログイン機能を作って。
           認証後は /analytics/dashboard にリダイレクト。
           既存の AuthService クラスを拡張する形で実装して」
```

**ポイント**: 説明文ではなく、**コードや実行結果**でコンテキストを共有する

---

## 2. ブラウザ状態の共有（Playwright MCP）

### 従来の課題

```
[開発者] ブラウザでDevTools開く
    ↓
[開発者] 「この要素は div.v-list-item__title で...」と説明
    ↓
[AI] 説明から推測してコード生成（精度低い）
```

### 新しいアプローチ

```
[開発者] 「このページのスナップショット取って」
    ↓
[AI/MCP] ブラウザを操作、DOM構造を取得
    ↓
[AI] 実際のDOM構造からコード生成（精度高い）
```

### Playwright MCPの活用例

```python
# AIがブラウザを操作してDOM構造を理解
# → 適切なロケーターを自動提案

# 従来（開発者が手動でXPathを取得）
self.clickByXpath('//div[@class="v-list-item__title" and text()="応募者"]')

# AI駆動（DOM構造から自動生成）
page.get_by_role("button", name="応募者").click()
```

### セットアップ

```json
// ~/.cursor/mcp.json
{
  "mcpServers": {
    "playwright": {
      "command": "npx",
      "args": ["-y", "@playwright/mcp@latest"]
    }
  }
}
```

---

## 3. API状態の共有

### 従来の課題

```
[開発者] 「APIはこういうレスポンスを返して...」
    ↓
[開発者] レスポンス例をコピペ、またはスクショ
    ↓
[AI] 不完全な情報から推測
```

### 新しいアプローチ

```
[開発者] 「このAPIを叩いて結果を見て」
    ↓
[AI] curl等でAPI実行、レスポンスを直接取得
    ↓
[AI] 実際のデータ構造からコード生成
```

### 実践例

```bash
# AIがAPI実行結果を直接確認
curl -s "https://api.example.com/v3/applicants" \
  -H "Authorization: Bearer $TOKEN" | jq '.data[0]'

# レスポンス例
{
  "id": 123,
  "name": "山田太郎",
  "status": "applied",
  "diagnosis_result": {
    "score": 85,
    "completed_at": "2026-01-13T10:00:00Z"
  }
}

# → AIがこの構造を理解して、型定義やUIコンポーネントを生成
```

---

## 4. フロントエンド＋バックエンド統合理解

### 全体像

```
┌─────────────────────────────────────────────────┐
│              統合開発フロー                      │
├─────────────────────────────────────────────────┤
│                                                 │
│  [フロントエンド]        [バックエンド]          │
│   Playwright MCP          curl / API Client     │
│        │                       │                │
│        ▼                       ▼                │
│   ・UI状態                 ・APIレスポンス       │
│   ・DOM構造                ・データ構造          │
│   ・ユーザー操作           ・バリデーション      │
│        │                       │                │
│        └──────────┬────────────┘                │
│                   ▼                             │
│          全体理解に基づいた                      │
│          ・コード生成                           │
│          ・バグ検出                             │
│          ・テスト提案                           │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 実践例：応募者登録機能の開発

```
[開発者] 「応募者登録フローを実装したい」

[AI] 1. API仕様を確認
     POST /v3/applicants
     リクエスト: { name, email, position_id }
     レスポンス: { id, name, status, ... }

     2. 現在のUI構造を確認（Playwright）
     - 入力フォームの構造
     - バリデーションメッセージの表示位置
     - 送信ボタンの状態管理

     3. 実装提案
     - フォームコンポーネント
     - API呼び出しサービス
     - エラーハンドリング
     - 成功時のリダイレクト
```

---

## 5. リモートサーバー操作

### SSH経由でのコマンド実行

AIエディタからSSH経由でリモートサーバーを操作し、以下を実現：

- デプロイ（git pull）
- 実行・テスト
- ログ確認・分析
- 環境セットアップ

### 実践例

```bash
# AIがSSH経由でサーバー操作
ssh user@server << 'EOF'
cd ~/app
git pull origin master
source .venv/bin/activate
python manage.py test
EOF

# 結果をAIが分析
# → テスト失敗時は原因特定・修正提案
```

---

## 6. 開発フローの実践パターン

### パターン1: 新機能開発

```
1. [人間] 要件を説明（ビジネスロジック、ドメイン知識）
2. [AI] 既存コードを分析、実装方針を提案
3. [人間] 方針を承認・調整
4. [AI] コード生成
5. [AI] Playwright/APIでセルフテスト
6. [人間] レビュー・微調整
7. [AI] デプロイ・動作確認
```

### パターン2: バグ修正

```
1. [人間] バグの症状を説明
2. [AI] ログ確認、UI状態確認、API確認
3. [AI] 原因を特定、修正案を提案
4. [人間] 修正方針を承認
5. [AI] コード修正
6. [AI] 再現テスト→修正確認
```

### パターン3: リファクタリング

```
1. [人間] リファクタリングの目的を説明
2. [AI] 影響範囲を分析
3. [AI] 段階的な修正計画を提案
4. [人間] 計画を承認
5. [AI] 各ステップでコード修正→テスト
6. [AI] 全体の動作確認
```

---

## 7. チームでの活用

### 共有すべきもの

| 項目 | 内容 |
|------|------|
| MCPの設定 | `~/.cursor/mcp.json` |
| APIクライアント | 認証込みのcurlラッパー等 |
| テストデータ | Seeds、Fixtures |
| ドメイン知識 | ビジネスルールのドキュメント |

### ナレッジの蓄積

```
プロジェクト/
├── docs/
│   ├── domain/          # ドメイン知識
│   │   ├── applicant.md # 応募者に関するビジネスルール
│   │   └── diagnosis.md # 診断に関するビジネスルール
│   ├── api/             # API仕様・使用例
│   └── patterns/        # 実装パターン集
└── scripts/
    └── ai-tools/        # AI開発支援スクリプト
        ├── api-client.sh
        └── test-runner.sh
```

---

## 8. 一部の検証結果（2026-01-21）

### 実施内容

あるプロジェクトで、PHP Deprecation警告修正PRの検証を実施。
本ドキュメントの構想を実際に試し、課題を洗い出した。

**実装したもの**:
- `local/ai_verify/` - 検証ツール群
  - `auth.sh` - 認証ツール
  - `api_call.sh` / `session_api.sh` - API呼び出し
  - MCP Browser連携によるUI操作

### 課題の分類

| 種類 | 課題 | 性質 | 対処 |
|------|------|------|------|
| **普遍的** | コンテキスト消失 | AI開発の本質的限界 | 定期的な再確認、ドキュメント化 |
| **普遍的** | ドメイン知識の壁 | 人間の介入が必要 | 人間がヒントを与える設計 |
| **固有** | 認証の複雑さ | プロダクト依存 | 一度スクリプト化すれば解決 |
| **固有** | MCP制限 | ツール依存 | 代替手段をドキュメント化 |

### 普遍的課題への対処

**コンテキスト消失**:
- AIは長期記憶を持たない
- セッションが長くなると以前の情報が薄れる
- **対処**: ドキュメントを「AIの外部記憶」として活用

```
セッション中の発見 → 即ドキュメント化 → 次セッションで参照
```

**ドメイン知識の壁**:
- AIは「何を叩くべきか」はコードから導出できる
- しかし「なぜ動かないか」「どのデータが必要か」は判断できない
- **対処**: 人間がヒントを与える→AIが調査する分業

```
AI: "403エラーが返ってきます"
Human: "必要なドメインデータがないのでは？"
AI: (調査して解決策を提案)
```

### プロダクト固有課題への対処

これらは**一度明文化・スクリプト化すれば解決**する。

- 認証方式 → `session_api.sh` に実装済み
- MCP制限 → `ARCHITECTURE.md` に代替手段を記載
- API仕様 → OpenAPI / Routingファイル から導出可能

---

## 9. 今後の展望

### 短期（実用段階）

- [x] プロジェクト固有のAPIクライアント整備 ← 完了
- [ ] よく使うテストシナリオのスクリプト化
- [ ] ドメイン知識のドキュメント化

### 中期（効率化）

- [ ] E2Eテストの自動生成
- [ ] コードレビューの自動化
- [ ] ドキュメント生成の自動化
- [ ] 変更影響分析スクリプト

### 長期（発展）

- [ ] 自然言語からの機能実装
- [ ] バグの自動検出・修正
- [ ] 最適化提案の自動生成
- [ ] 並列エージェントによる分業

---

## 9. 参考資料

- [Playwright MCP](https://github.com/anthropics/mcp)
- [Cursor Documentation](https://docs.cursor.com/)
- [Model Context Protocol](https://modelcontextprotocol.io/)

---

## 更新履歴

| 日付 | 内容                     |
|------|------------------------|
| 2026-01-13 | 初版作成。RPA開発での検証結果を基に作成  |
| 2026-01-21 | 検証結果追記。実際のプロダクトでの実践を反映 |