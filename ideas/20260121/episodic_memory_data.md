# エピソード記憶的データ：プロダクトの経緯を理解するためのデータ分類

## 背景：人間の記憶の分類

認知科学では、人間の長期記憶を大きく2つに分類する：

| 種類 | 内容 | 例 |
|------|------|-----|
| **Semantic Memory（意味記憶）** | 事実・知識・概念 | 「東京は日本の首都」「Pythonはプログラミング言語」 |
| **Episodic Memory（エピソード記憶）** | 経験・出来事・文脈 | 「去年の夏、東京に行った時、渋谷で迷った」 |

重要な違い：
- 意味記憶は「What（何）」を知っている
- エピソード記憶は「When（いつ）」「Where（どこで）」「Why（なぜ）」「How（どのように）」を含む

---

## 現在のRAG/AIシステムの限界

現在のほとんどのシステムは**意味記憶的**なアプローチに偏っている：

```
クエリ: 「認証機能について教えて」

現在のRAG（意味記憶的）:
→ 「認証機能はJWTを使用しています」
→ 「ファイルはauth.tsにあります」
→ 類似度の高いドキュメントを返す

欠けているもの（エピソード記憶的）:
→ 「なぜJWTを選んだのか」
→ 「最初はOAuth2だったが、いつ、なぜ変更されたのか」
→ 「その時どんな議論があったのか」
→ 「誰がその決定に関わったのか」
```

---

## プロダクト開発における「エピソード記憶的データ」

プロダクトやコードベースにも「経緯」がある。これを意識的に分類・蓄積することで、より深い文脈理解が可能になる。

### データの分類

#### 意味記憶的データ（What）
- コード自体
- ドキュメント
- API仕様
- 設定ファイル

#### エピソード記憶的データ（When / Why / How / Who）
- コミット履歴とコミットメッセージ
- PR/MRのディスカッション
- Issueの議論
- ADR（Architecture Decision Records）
- Slackでの技術議論
- レビューコメント
- **AIとのやりとり履歴**（新しいカテゴリ）

---

## エピソード記憶的データの構造

単なるログではなく、以下の要素を持つ構造化されたデータ：

```
Episode {
  timestamp:    いつ起きたか
  entity:       何に関することか（機能、ファイル、概念）
  event_type:   何が起きたか（作成、変更、議論、決定、問題発生、解決）
  actors:       誰が関わったか
  context:      なぜそうなったか（背景、制約、要件）
  outcome:      結果どうなったか
  artifacts:    関連する成果物（PR、Issue、ドキュメントへのリンク）
  connections:  他のエピソードとの関連
}
```

### 例：認証機能の経緯

```json
[
  {
    "timestamp": "2024-03-15",
    "entity": "認証システム",
    "event_type": "initial_design",
    "actors": ["田中"],
    "context": "Google Workspaceを使っているのでOAuth2が自然だった",
    "outcome": "OAuth2で実装することに決定",
    "artifacts": ["設計doc", "Issue #45"]
  },
  {
    "timestamp": "2024-06-01",
    "entity": "認証システム",
    "event_type": "problem_discovered",
    "actors": ["セキュリティチーム"],
    "context": "監査でトークン有効期限が長すぎると指摘",
    "outcome": "修正が必要",
    "artifacts": ["監査レポート", "Issue #123"]
  },
  {
    "timestamp": "2024-06-15",
    "entity": "認証システム",
    "event_type": "decision",
    "actors": ["田中", "鈴木", "セキュリティチーム"],
    "context": "OAuth2のまま修正するか、JWT方式に変えるか議論",
    "outcome": "JWT方式に移行。理由：より細かい制御が可能、監査要件を満たしやすい",
    "artifacts": ["ADR-005", "Slack #tech-auth 2024-06-15"]
  },
  {
    "timestamp": "2024-07-01",
    "entity": "認証システム",
    "event_type": "implementation",
    "actors": ["鈴木"],
    "context": "ADR-005に基づいて実装",
    "outcome": "JWT認証に移行完了",
    "artifacts": ["PR #456"]
  }
]
```

---

## 重み付けとしての活用

エピソード記憶的データは、検索や推薦の「重み付け」として使える：

### 1. 時間的重み
- 最近のエピソードほど現状を反映している可能性が高い
- ただし、古いエピソードが「なぜ今こうなっているか」の根拠になる

### 2. イベントタイプによる重み
```
decision（決定）       → 高い重み（意図的な選択）
problem_discovered    → 高い重み（制約や注意点）
implementation        → 中程度（事実）
discussion           → 低め（検討段階、採用されなかった案も含む）
```

### 3. 関連性による重み
- 同じentityに関するエピソードをチェーンとして辿れる
- 「この決定は、あの問題から生まれた」という因果関係

### 4. アクターによる重み
- 特定の人が関わったエピソードを重視
- 「この領域は田中さんが詳しい」という暗黙知の可視化

---

## RAGとの統合

従来のRAG（意味記憶的）とエピソード記憶的検索を組み合わせる：

```
クエリ: 「認証機能を修正したい」

Step 1: 意味記憶的検索
→ 関連コード、ドキュメントを取得

Step 2: エピソード記憶的検索
→ 「認証」に関連するエピソードを時系列で取得
→ 特にdecision、problem_discoveredタイプを重視

Step 3: 統合して回答
→ 「認証機能はJWTを使用しています（コード参照）」
→ 「2024年6月にOAuth2から移行しました（エピソード参照）」
→ 「移行理由は監査対応です（エピソード参照）」
→ 「詳細はADR-005を参照してください（成果物リンク）」
```

---

## AIやりとりとの接続

AIとの開発やりとりは、自動的にエピソード記憶的データを生成する：

```
AIやりとり → 自動的に以下が記録される：
- いつ（timestamp）
- 何について（entity: 議論対象のファイルや機能）
- 何が起きたか（event_type: 質問、実装、デバッグ、設計議論）
- なぜ（context: プロンプトに含まれる背景説明）
- 結果（outcome: 採用されたコード、却下された案）
```

これは従来のGit履歴やIssueにはない、**意思決定プロセスの詳細な記録**になる。

---

## 実装への示唆

### 短期的
- AIやりとりをログする際、上記の構造を意識してメタデータを付与
- 最低限：timestamp、entity（関連ファイル/機能）、outcome（採用/修正/却下）

### 中期的
- エピソードを検索可能にする
- 「この機能の経緯を教えて」に答えられるようにする

### 長期的
- エピソード記憶を理解するガイドAgentを構築
- 意味記憶的RAGとエピソード記憶的検索を統合

---

## 結論

「エピソード記憶的データ」という分類は、以下の点で価値がある：

1. **既存データの再解釈**: Git履歴、Issue、PRは既にエピソード記憶的データだが、そう認識されていない
2. **新しいデータソース**: AIやりとりは豊富なエピソード記憶的データを生成する
3. **検索の質向上**: 「何があるか」だけでなく「なぜそうなったか」に答えられる
4. **重み付けの軸**: 時間、イベントタイプ、アクターなど多次元の重み付けが可能

プロダクト開発において、コードやドキュメント（意味記憶）と同等に、経緯や決定プロセス（エピソード記憶）を資産として扱うべき。
