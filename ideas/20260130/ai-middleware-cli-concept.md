# AI開発効率化のためのミドルウェアCLI構想

> AI CLI（Cursor、Claude Code等）と人間の間に挟まる「薄いツール層」のアイデア整理

## 前提：AI CLIツールの重要性

### 現状の観察

**今すでに起きていること**:
- Cursor、Claude Code、Windsurf、Cline 等が実用段階に入っている
- ターミナル操作をAIに任せる開発スタイルが普及しつつある
- MCPでツール連携の標準化が進んでいる

**不確実な部分**:
- これが「一時的なブーム」か「不可逆的なシフト」か
- AI CLIが主流になるのか、別のインターフェース（GUI操作、自然言語のみ）に置き換わるのか
- 「AIがCLIを使う」のか「AIのためのAPI/プロトコルが別に生まれる」のか

### 考えられるシナリオ

| シナリオ | 概要 | ミドルウェアCLI層の価値 |
|---------|------|----------------------|
| A: CLI中心が続く | Unix哲学とAIの相性が良く、既存エコシステム活用 | 高い |
| B: AIネイティブプロトコルが主流 | MCPの発展形がCLIを置き換える | CLI層より MCP/API層に投資すべき |
| C: GUI操作エージェントが主流 | Computer Use/Browser Useが発展 | CLI特化ツールは限定的 |
| D: ハイブリッド | 用途によって使い分け（開発はCLI、エンドユーザーはGUI） | 開発者向けニッチとして残る |

### 時間軸での見立て

**短期（1-2年）**: シナリオA寄り。CLIベースのAI開発が主流。既存ツールとの統合が現実的。

**中長期（3-5年）**: シナリオDに収束する可能性。AIネイティブなプロトコル（MCP発展形）と、既存CLI/APIの共存。

**理由**:
- 既存のCLIエコシステムは巨大で、すぐには置き換わらない
- ただし「AIが人間向けCLIを使う」のは本質的には非効率（テキストパースが必要）
- 長期的にはAI-to-AI通信に最適化されたプロトコルが出てくるはず

### このドキュメントの位置づけ

上記を踏まえた上で、**短期〜中期で価値があり、長期でも開発者向けニッチとして残る可能性がある**領域としてミドルウェアCLI層を検討する。

---

## 背景・問題意識

### 現状

AI CLIやAI IDEでターミナルを操作させて開発することが増えてきた。既存のCLIコマンドやOSのCLIツールは活用できるが、**AI駆動開発に特化したツール**は存在しない。

### 着眼点

オーケストレーションフレームワークやマルチエージェント基盤は別途検討するとして、その手前の層として：

> **「人間 ↔ AI CLI」の間に挟まる、薄いミドルウェア的CLIツール群**

を構築することで、より効率的かつ再現性のある開発ができないか。

```
┌──────────────┐
│   Human      │
└──────┬───────┘
       │ ← ★ミドルウェアCLI層
       ▼
┌──────────────┐
│  AI CLI      │  (Cursor, Claude Code, etc.)
│  (既存)      │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  Codebase    │
└──────────────┘
```

---

## この層で解決できること

### 1. 入力の前処理（AIに渡す前）

- タスク記述の構造化・明確化
- 関連コンテキストの自動収集と圧縮
- 過去の類似タスクや決定事項の参照付与

### 2. 出力の後処理（AIから受け取った後）

- 生成物の検証・lint
- 変更内容のサマリ生成
- 実行ログの構造化保存

### 3. セッション間の橋渡し

- 前回の作業状態の復元
- 中断したタスクの再開に必要な情報の再構成

---

## コンテキスト「純度」の問題

### 問題

MCP toolsやCursorのスキルは便利だが、**呼び出し結果がコンテキストに入る**のは変わらない。検索10件分のスニペットが入ってきたら、それだけでトークン消費するし、AIの「注意」がそっちに引っ張られる。

```
┌─────────────────────────────────────────────────┐
│  AI Context Window                              │
│  ┌───────────────────────────────────────────┐  │
│  │ ・タスク理解                               │  │
│  │ ・ウェブ検索結果（ノイズ含む）             │  │
│  │ ・検索結果の要約処理                       │  │
│  │ ・関連/非関連の判断                        │  │
│  │ ・フォーマット整形                         │  │
│  │ ・実際の思考・生成  ← 本来ここに集中したい │  │
│  └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

### 提案：AIの外側で「前処理済み情報」を作る

```
┌──────────────┐
│   Human      │  "OAuth2のベストプラクティス調べて"
└──────┬───────┘
       │
       ▼
┌──────────────────────────────────────┐
│  Pre-processing CLI Layer            │  ← ★ここ
│  ・検索実行（従来のCLI/API）          │
│  ・結果のフィルタリング・ランキング   │
│  ・一次情報の抽出                     │
│  ・構造化・圧縮                       │
│  ※ここでAI使ってもいいが「軽量モデル」│
└──────────────────────────────────────┘
       │
       ▼ 「精製された情報」だけ渡す
┌──────────────────────────────────────┐
│  Main AI (Cursor/Claude Code)        │
│  ・本質的な判断                       │
│  ・コード生成                         │
│  ・設計決定                           │
└──────────────────────────────────────┘
```

---

## 具体的なコマンド候補

### 入力系

```bash
# タスク + 関連コンテキストを結合したprompt生成
ai-prep "OAuth実装して" --scan ./src --depth 2

# 前回の作業コンテキストを復元
ai-resume --last

# 過去の決定事項を検索
ai-ref "認証周りの過去の決定"
```

### 出力系

```bash
# AIの出力を構造化して保存
ai-capture --from clipboard --tag "oauth-implementation"

# 直近の変更を検証
ai-verify ./src/Auth/

# git diffから「何をしたか」のサマリを生成
ai-diff-explain
```

### 橋渡し系

```bash
# 現在の状態、残タスク、注意点をドキュメント化
ai-handoff --to "明日の自分" --task "OAuth実装の続き"

# 過去のセッションの作業を再現可能な形で表示
ai-replay ./logs/2024-01-15-oauth.json
```

### 調査系（コンテキスト精製）

```bash
# ウェブ調査の前処理
research "OAuth2 PKCE implementation best practices" \
  --sources official,rfc,reputable \
  --exclude stackoverflow,medium \
  --extract-primary \
  --compress

# ドキュメントから該当部分だけ抽出
doc-extract "CakePHP Authentication plugin" \
  --version 3.x \
  --focus "middleware configuration" \
  --format outline

# 検索結果の精製
cat search_results.json | refine \
  --keep-primary-sources \
  --dedupe \
  --rank-by relevance \
  --limit 3 \
  --summarize

# コードベース情報の精製
codebase-distill ./src \
  --question "認証フローはどうなってる？" \
  --depth shallow \
  --output digest
```

---

## AIモデル視点で「欲しい」ツール

AIモデル自身が、自分の生成精度を高めるために「あったら嬉しい」と思うツール群：

### 1. 曖昧さ解消ツール

```bash
disambiguate "認証を実装して"
# 出力:
# - 認証方式: [session / JWT / OAuth2 / ...] 
# - 対象: [API / Web UI / 両方]
# - 既存実装: [なし / 拡張 / 置換]
```

人間の指示は曖昧なことが多い。**推測に使うトークンと注意を節約**できたら、本質的な生成に集中できる。

### 2. 制約・前提の明示化ツール

```bash
constraints-for ./src/Auth/
# 出力:
# - PHP 8.1+ required
# - CakePHP 4.x patterns expected
# - Existing: AuthenticationMiddleware使用
# - 命名規則: PascalCase for classes
```

AIは「このプロジェクトでは何が許されて何がダメか」を推測するのにトークンを使う。**事前に制約が明示されてれば、その分生成に回せる**。

### 3. 類似実装の参照ツール

```bash
similar-impl "ユーザー削除機能" --in ./src
# 出力:
# - src/Controller/UsersController.php:delete() が類似パターン
# - 削除時の関連処理: AuditLog記録、関連レコードのcascade
# - テストパターン: tests/Controller/UsersControllerTest.php
```

「このプロジェクトでの"正解"の書き方」を知りたい。**既存の類似実装を参照できると、プロジェクトのイディオムに沿った生成ができる**。

### 4. 用語・概念の正規化ツール

```bash
normalize-terms "ユーザ" "会員" "アカウント" --context ./src
# 出力:
# - このプロジェクトでは "User" で統一
# - DB: users table
# - Model: App\Model\Entity\User
# - 「会員」は顧客向けUI表示のみで使用
```

同じ概念が複数の言葉で呼ばれてると、AIは「これ同じもの？違うもの？」で迷う。**正規化された用語マップがあると、一貫した生成ができる**。

### 5. 検証可能な成功条件ツール

```bash
success-criteria "OAuth実装" --generate
# 出力:
# - [ ] GET /auth/google でリダイレクト
# - [ ] callback処理でユーザー作成/ログイン
# - [ ] 既存ユーザーとのマージ処理
# - [ ] テストカバレッジ 80%以上
# - 検証コマンド: ./verify-oauth.sh
```

「できた」の定義が曖昧だと、AIは「たぶんこれでいいはず」で止まる。**明確な検証条件があれば、そこに向かって生成できる**。

### 6. コンテキスト重要度スコアリング

```bash
context-rank ./docs/*.md --for "認証フロー実装"
# 出力:
# 1. docs/auth-spec.md (0.95) - 直接関連
# 2. docs/api-design.md (0.72) - 部分関連
# 3. docs/deployment.md (0.15) - ほぼ無関係
```

AIのコンテキストに入れる情報は、**重要度順に入れてほしい**。全部フラットに入ると、どこに注目すべきかの判断にトークンを使う。

### 7. フィードバック構造化ツール

```bash
feedback-parse "これじゃなくて、もっとシンプルに"
# 出力:
# - 問題: 複雑すぎる
# - 方向: 簡素化
# - 具体的指示: 不明確
# - 推奨質問: "どの部分を簡素化しますか？（クラス構造/メソッド数/依存関係）"
```

曖昧なフィードバックを受けると、AIは「何がダメだったんだろう」の推測に労力を使う。**フィードバックが構造化されてれば、修正方向が明確になる**。

---

## 既存ルール/処理からの抽出候補

今すでにやっていることからCLI化できそうなもの：

| 今やってること | 抽出したCLIコマンド |
|---------------|-------------------|
| カーソルルールで「このプロジェクトはCakePHP」と書いてる | `project-context detect` → 自動検出 |
| 毎回「PHPのバージョンは8.1」と伝えてる | `env-constraints` → composer.json等から抽出 |
| エラーが出たら関連ファイルを手動で集めてる | `error-context <エラー文>` → 自動収集 |
| 「前にこう決めた」を思い出して伝えてる | `decisions search <キーワード>` → 過去決定の検索 |
| 仕様書のこの部分を見てと指示してる | `spec-extract <仕様書> --section <セクション>` |

---

## 設計原則

### この層のポイント

1. **AIの中身には触らない**: Cursor/Claude Code/Windsurfがどう動くかは関係ない
2. **入出力を標準化**: どのAI CLIを使っても、同じミドルウェア層が使える
3. **状態を外部化**: AIのコンテキストウィンドウに頼らず、ファイルシステムに永続化
4. **composable**: 各コマンドは単機能で、パイプで繋げられる

### AIコンテキスト精製の原則

1. **AIコンテキストの「純度」を守る**: Main AIには精製済み情報だけ渡す
2. **一次情報を優先**: RFC、公式ドキュメント、ソースコードを優先
3. **処理は軽量に**: この層でAI使う場合も、Haiku級の軽量モデル or 従来のアルゴリズム
4. **透明性**: 何をフィルタしたか、何を残したかのログ

---

## 期待される効果

| 観点 | 現状 | この層を入れると |
|------|------|-----------------|
| コンテキスト効率 | 検索結果がそのまま入る | 精製済みの要点だけ |
| AIの注意配分 | ノイズにも注意が分散 | 本質に集中 |
| 一次情報率 | 検索エンジン依存 | 意図的に一次情報優先 |
| 再現性 | 検索結果は毎回変わる | 精製結果をキャッシュ可能 |
| セッション継続性 | コンテキスト消失 | 外部に状態保存 |

---

## 検討事項

### この層自体にAIを使うか？

- **使う場合**: より賢いフィルタリング、要約が可能
- **使わない場合**: 決定論的で再現性高い、ただし精度は落ちる
- **ハイブリッド**: 軽量モデルで粗いフィルタ → 従来処理で整形

### どこまでこの層でやるか？

やりすぎると、本来Main AIが判断すべきことまで先に決めてしまう。「情報の収集・整形」と「判断・生成」の境界をどこに引くか。

---

## 次のステップ

1. **繰り返しやってるパターンの洗い出し**: 実際の作業から抽出
2. **優先度高いものから小さく作る**: 1コマンドずつ検証
3. **個別リポジトリで公開**: 汎用的に使えるレベルになったら

---

## 関連アイデア

- [生成AI利用開発の本質的課題と現状認識](./generative-ai-development-challenges.md) — 本質的課題のリスト、現状の対策の限界、ブレークスルーが必要な領域
- [AI向けインターフェース・フレームワークの可能性](./ai-native-interface-concept.md) — 「人間向け」から「AI向け」へのインターフェース転換、レビュー問題と中間言語の逆転
- [AIエージェント・オーケストレーション](../20260121/ai-agent-orchestration.md) — より大きなシステムの構想
- [エピソード記憶的データ](../20260121/episodic_memory_data.md) — 経緯・文脈の蓄積

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-30 | 初版作成。ブレインストーミングの内容を整理 |
