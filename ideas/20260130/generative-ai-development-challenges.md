# 生成AI利用開発の本質的課題と現状認識

> AI駆動開発における本質的な課題、現状の対策の限界、今後の展望についての整理

## 背景

[AI開発効率化のためのミドルウェアCLI構想](./ai-middleware-cli-concept.md) の議論過程で浮かび上がった、生成AIを利用した開発における本質的な課題の整理。

---

## 現状認識：Breakthroughは起きていない

### この2年間で起きたこと

| 時期 | 変化 | 本質 |
|------|------|------|
| GPT-3.5→4 | 精度向上 | 同じことがより正確に |
| ChatGPT→Cursor | UIの進化 | 同じことがより楽に |
| 単発→MCP/Agent | 統合の進化 | 同じことがより自動で |
| プロンプト→ルール/メモリ | 永続化 | 同じことを繰り返さなくていい |

**どれも「既存の作業を効率化」であって、「できなかったことができる」ではない。**

### 変わったこと / 変わってないこと

**変わったこと**:
- 習熟コストの低下（誰でもそこそこのコードが書ける）
- 作業速度の向上（特に定型的な部分）
- 調査・学習の効率化

**変わってないこと**:
- 難しい問題は難しいまま
- 設計判断は人間がやる
- ドメイン知識は人間が持つ必要がある
- バグは出るし、レビューは必要

---

## 本質的課題のリスト

### 1. コンテキスト消失

**問題**: AIは長期記憶を持たない。セッションが長くなると以前の情報が薄れる。コンテキストウィンドウは有限。

**現状の対策**:
- プロンプトの工夫
- ドキュメント化（外部記憶として）
- メモリ機能（Claude Memory, Cursor等）
- RAG

**対策の限界**: どれも「人間が補助輪をつけてる」状態。モデル自体が解決してるわけじゃない。

**本質的に必要なこと**: モデルが真の長期記憶を持つ。経験から学習・保持できる。

---

### 2. ドメイン理解の欠如

**問題**: AIは汎用的な知識は持つが、特定プロジェクト/ドメインの文脈を理解していない。毎回説明が必要。

**現状の対策**:
- 毎回説明する
- ルール/プロンプトへの注入
- RAGでドキュメント参照
- Few-shot examples

**対策の限界**: 注入できる量に限界がある。「暗黙知」は言語化が難しい。

**本質的に必要なこと**: モデルがドメインを学習・保持できる。プロジェクト固有の文脈を内在化。

---

### 3. 成果物の劣化

**問題**: AI生成コードは時間とともに、または大規模になると品質が劣化する傾向。一貫性が失われる。

**現状の対策**:
- 人間によるレビュー
- lint、静的解析
- テスト
- 既存パターンの提示

**対策の限界**: レビューがボトルネックになる。AI生成速度 >> 人間レビュー速度。

**本質的に必要なこと**: モデルが自己検証・修正できる。内省的な正しさの判断。

---

### 4. 再利用性の低下

**問題**: AI生成コードは局所最適になりがち。コードベース全体の一貫性、再利用性が考慮されない。

**現状の対策**:
- 規約の明文化
- パターン提示
- 既存コードの参照指示

**対策の限界**: 全部をコンテキストに入れられない。AIは「今のタスク」に集中しがち。

**本質的に必要なこと**: モデルがコードベース全体を理解。アーキテクチャレベルの判断。

---

### 5. 自律的イテレーションの限界

**問題**: AIが自律的に試行錯誤を回せない。人間がチェックポイントで介入する必要がある。

**現状の対策**:
- 人間が段階的に指示
- エージェントフレームワーク
- ワークフローの自動化

**対策の限界**: 「判断」の部分で人間が必要。AIだけで回すと暴走リスク。

**本質的に必要なこと**: モデルが信頼できる判断をする。不確実性を正確に認識。

---

### 6. 曖昧さへの対処

**問題**: 人間の指示は曖昧。AIは推測で進めるが、その推測が正しいとは限らない。

**現状の対策**:
- プロンプトを詳細に書く
- 曖昧な場合は質問させる
- テンプレート化

**対策の限界**: 人間側の負荷が増える。「いい感じに」やってほしいのにできない。

**本質的に必要なこと**: モデルが文脈から適切に推論。または適切なタイミングで確認。

---

### 7. 確率的出力の不安定性

**問題**: 同じ入力でも出力がブレる。再現性がない。

**現状の対策**:
- temperatureを下げる
- seed固定（一部モデル）
- 出力形式を厳密に指定

**対策の限界**: 完全な再現性は得られない。本質的に確率的。

**本質的に必要なこと**: 必要に応じて決定論的な出力。または不確実性の明示。

---

## 現状の対策と本質的解決の対比

| 課題 | 今やってる対策 | 本質的に必要なこと |
|------|---------------|-------------------|
| コンテキスト消失 | プロンプト工夫、ドキュメント化、メモリ機能 | モデルが長期記憶を持つ |
| ドメイン理解の欠如 | 毎回説明、ルール注入、RAG | モデルがドメインを学習・保持 |
| 成果物の劣化 | レビュー、lint、テスト | モデルが自己検証・修正できる |
| 再利用性の低下 | 規約の明文化、パターン提示 | モデルがコードベース全体を理解 |
| 自律的イテレーション | 人間がチェックポイントで介入 | モデルが信頼できる判断をする |
| 曖昧さへの対処 | 詳細なプロンプト | 文脈からの適切な推論 |
| 確率的不安定性 | temperature調整 | 決定論的出力 or 不確実性の明示 |

**共通点**: どれも「人間が補助輪をつけてる」状態で、モデル自体が解決してるわけじゃない。

---

## フロー/プロンプトの限界

どれだけ工夫しても超えられない壁：

- **コンテキストウィンドウは有限** → 全部は入らない
- **プロンプトは毎回リセット** → 学習が蓄積しない
- **モデルは確率的** → 同じ入力でも出力がブレる
- **自己認識がない** → 「わからない」「間違えた」を正確に判断できない

これらはプロンプトやフローでは超えられない。**モデルアーキテクチャレベルの変化**が必要。

---

## ブレークスルーが必要な領域

| 領域 | 現状 | 必要な変化 |
|------|------|-----------|
| メモリ | セッション内のみ / 外部DB参照 | 真の長期記憶、経験からの学習 |
| 自己検証 | 外部ツール（テスト、lint）に依存 | 内省的な正しさの判断 |
| 計画・分解 | 人間が粒度を指示 | 自律的なタスク分解と優先度判断 |
| 不確実性の認識 | 「自信がない」が不正確 | 校正された不確実性の表現 |

---

## 今できることの位置づけ

### 二層構造で考える

- **待つ**: モデルの進化、新しいアーキテクチャ、研究のブレークスルー
- **やる**: 手作業の自動化、ログの蓄積、再現性の確保

外部ツール（CLI等）で対応できるのは「やる」側。本質的解決は「待つ」しかない。

### 「やる」ことの価値

1. **ブレークスルーが来るまでの間、現実の仕事は止められない**
   - 今日の仕事は今日やる
   - その間の効率化には意味がある

2. **モデル進化が遅い/頭打ちになった場合の保険**
   - モデルが80点止まりなら、残り20点を埋める仕組みに意味がある
   - モデルが99点になるなら、その仕組みは不要になる

3. **ドメイン固有の問題は残る**
   - 汎用モデルが進化しても、自社/自分のコードベース、ドメイン知識、ワークフローを理解してるわけじゃない
   - ここは常に「自分で埋める」領域

---

## 外部ツール構築の判断軸

### 作成コストの再評価

**従来の計算**:
```
作成コスト（人間の時間）vs 節約できる時間
→ 100時間かけて年10時間節約 = 割に合わない
```

**今の計算**:
```
作成コスト（AIに作らせる + 動作確認）vs 節約できる時間
→ 2時間で作って年10時間節約 = 余裕でペイする
```

**作成コスト自体がAIで1-2桁下がっている**。損益分岐点が根本的に変わった。

### スクラップ&ビルドの有効性

| 観点 | 従来 | AI時代 |
|------|------|--------|
| 作り直しコスト | 高い（また数日かかる） | 低い（また数時間） |
| 「間違った方向」のリスク | 大きい（時間が無駄に） | 小さい（捨てればいい） |
| 試行回数 | 限られる | 多く回せる |
| 完成度の要求 | 最初から高く | 雑に作って改善 |

**小さいツールは「とりあえず作ってみる」が正解になった**。

### ベンダーロックイン回避

| 状況 | リスク |
|------|--------|
| Cursor使えなくなる | 会社の方針変更、課金されない、別プロジェクト |
| Claude Code使えなくなる | API制限、コスト、組織ポリシー |
| 特定MCPに依存 | そのツールがdeprecate |

**汎用的なCLIツールは、どのAI IDE/CLIでも使える**。自分の足場を持つ意味がある。

### 副次的メリット

1. **学習効果**: プロンプトの書き方、「AIが扱いやすい形式」の理解
2. **問題の言語化**: ツール化の過程で「本当の課題は何か」が見える
3. **実験の土台**: 新しいアイデアを試しやすい

---

## 結論

### 本質的課題について

- 現在の対策（フロー/プロンプト/外部ツール）では本質的に解決しない
- モデルアーキテクチャレベルのブレークスルーを待つしかない
- それがいつ来るか、来るかどうかは不明

### 今できることについて

- 本質的解決ではないが、**効率化・再現性向上**には意味がある
- 作成コストが下がったので、**試行のハードルが下がった**
- **「作っても無駄になるかも」より「作らないことで失う機会」**のほうが大きい可能性
- 小さく作って、効果を見て、続けるか捨てるか判断する

### 温度感

- **過度な期待はしない**: これがBreakthroughを起こすわけじゃない
- **でも無駄でもない**: ブレークスルーが来たときに活用できる土台になる
- **現実的に**: 今日の仕事を少しマシにする、くらいの期待値

---

## 関連

- [AI開発効率化のためのミドルウェアCLI構想](./ai-middleware-cli-concept.md) — 具体的なツール案
- [AI向けインターフェース・フレームワークの可能性](./ai-native-interface-concept.md) — より長期的な視点での議論

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-30 | 初版作成。ブレインストーミングから抽出した本質的課題の整理 |
