# AI駆動検証フロー - 設計原則

## 概要

AIエージェント（Cursor, GitHub Copilot, Claude等）との協調による開発検証フローの設計思想をまとめたドキュメント。

---

## 対象アーキテクチャ

本ツールは以下のような一般的なWebサービス構成を想定しています:

| レイヤー | 想定技術 |
|---------|---------|
| **フロントエンド** | SPA（Single Page Application） |
| **バックエンド** | REST API |
| **API仕様** | OpenAPI / Swagger |
| **認証・認可** | JWT（OAuth2/OIDC）、Session + CSRF |
| **IdP** | AWS Cognito, Auth0, Firebase Auth 等 |
| **エラー監視** | Sentry, Datadog, New Relic 等 |

この構成はモダンなWebアプリケーションの典型的なパターンであり、多くのプロジェクトに適用可能です。

---

## 根本的な課題認識

### AIエージェントの特性と限界

| 特性 | 得意なこと | 苦手なこと |
|------|-----------|-----------|
| **コンテキスト** | 提供された情報の処理 | 長期記憶の保持 |
| **ドメイン知識** | コードからの推論 | 暗黙的なビジネスルール |
| **実行能力** | CLIコマンドの実行 | GUI操作、ファイルアップロード |
| **判断** | パターンマッチング | 「なぜそうなるか」の根本原因特定 |

### 普遍的課題 vs プロジェクト固有課題

**普遍的課題**（AI開発の本質的限界、常に付きまとう）:

- **コンテキスト消失**: 長いセッションで情報が薄れる
- **ドメイン知識の壁**: 「なぜ403か」はAIだけでは判断できない
- **自律的仮説検証の限界**: 正しい仮説を立てるには背景知識が必要

**プロジェクト固有課題**（一度明文化すれば解決）:

- 認証の複雑さ（JWT/Session混在）→ スクリプト化
- ツール制限 → 代替手段のドキュメント化
- データ依存 → 再現手順のドキュメント化

**結論**: 固有課題は「一度わかれば解決」、普遍的課題は「運用で軽減」

---

## 設計原則

### 1. ドキュメントはコンテキストの永続化

AIは長期記憶を持たない。ドキュメントが唯一の「永続化されたコンテキスト」。

```
セッション中の発見 → 即座にドキュメント化 → 次セッションで参照可能
```

**悪い例**: "従来型APIは api_call.sh では動かない"

**良い例**: "従来型APIはSession認証のため、JWT Bearer Token のみの api_call.sh では401。session_api.sh を使い、Cookie + X-CSRF-Token を付与する必要がある。"

**必須ドキュメント**:

| ファイル | 目的 |
|----------|------|
| `VERIFICATION_CASES.md` | テストケースと再現手順 |
| `README.md` | ツールの使い方 |
| `STATUS.md` (推奨) | 検証の進捗状態 |
| このドキュメント | 設計思想と学び |

### 2. 言語選択の指針

| レイヤー | 言語 | 理由 |
|----------|------|------|
| CLI操作（認証・API・監視） | **Shell** | AIが直接実行、依存少 |
| ヘッドレスブラウザ操作 | **Python** | Playwright公式対応、複雑な状態管理 |

**原則**: シェルスクリプトで済むならシェルで。ブラウザ操作が必要な時だけPythonを呼ぶ。

```
AI → Shell (直接実行)     ← 推奨：即座に結果取得
AI → Python (スクリプト)  ← 必要時：UI操作、複雑フロー
```

### 3. 人間とAIの役割分担

| 人間が担当 | AIが担当 |
|-----------|---------|
| ビジネスロジックの定義 | 実装詳細の提案 |
| ドメイン知識の提供 | テストケース生成 |
| 最終判断 | 自動検証実行 |
| コンテキストの提供 | 結果分析・レポート |
| **認証情報の提供** | **認証フローの実行** |
| **異常時の仮説提示** | **仮説に基づく調査** |

**学び**: 

- AIは「どのAPIを叩くべきか」はコードから導出できる
- しかし「なぜ403になるか」「どのデータが必要か」はドメイン知識が必要
- 人間が「権限がないのでは？」とヒントを与えると、AIは調査を進められる

### 4. コンテキスト共有の質

AIの出力品質は、**提供するコンテキストの質**に依存する。

```
❌ 悪い例：「ステージングを検証して」

✅ 良い例：「PR #123 の修正について、
           /api/users エンドポイントを呼び出して
           HTTP 200 が返ることを確認して。
           Sentry Issue XXX が resolved になっているかも確認して」
```

**追加の注意点**:

```
⚠️ セッションが長くなると、以前の文脈が薄れる
対策: 重要な情報は定期的に再確認するか、ドキュメントに残す

例: "./scripts/session_api.sh を使って" と明示的に指示
    （AIが api_call.sh と混同することを防ぐ）
```

### 5. 段階的な検証

1. **API検証** → HTTPステータス確認
2. **レスポンス検証** → データ構造確認
3. **エラー監視確認** → Sentry等でエラー有無確認
4. **UI検証** → 画面動作確認（MCP Browser等）

### 6. 検証ケース導出のフレームワーク

検証ケースは以下のプロセスで導出：

```
Input:  PR番号, 修正ファイル
Process: コード解析 → 呼び出し元特定 → API/URLマッピング → エラー監視検索
Output: 再現手順リスト
```

1. PRの修正コードを確認
2. 該当関数が呼ばれるパスを特定
3. エラー監視ツール（Sentry等）で実際の発生URLを確認
4. 再現手順を推論

---

## アーキテクチャ

### 現在の実装（MVP）

```
┌─────────────────────────────────────────────────────────┐
│                    AI Agent                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   [シェルスクリプト層]         [外部API]                │
│    cognito_auth.sh (JWT)        Sentry API              │
│    api_call.sh (JWT認証)        その他監視ツール        │
│    session_api.sh (Session認証)                         │
│           │                          │                  │
│           ▼                          ▼                  │
│   ┌───────────────┐          ┌───────────────┐         │
│   │ Target API    │          │ Error Monitor │         │
│   │ (REST API)    │          │ (Sentry etc)  │         │
│   └───────────────┘          └───────────────┘         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 将来の拡張

詳細は [MULTI_AGENT_ORCHESTRATION.md](./MULTI_AGENT_ORCHESTRATION.md) を参照。

---

## 運用上の教訓

### 認証方式の複雑さ

**問題**: 単一の認証方式では全APIをカバーできない

**原因**: 
- モダンなAPIはJWT Bearer Token認証
- 従来型/内部APIはSession + CSRF認証
- 同一システム内で混在することがある

**対処**: 認証方式ごとにスクリプトを分離（`api_call.sh` / `session_api.sh`）

**教訓**: 認証方式はAPI層ごとに異なる可能性がある。事前調査が重要。

### bash互換性問題

**問題**: `${1^^}` (大文字変換) がmacOSのbash 3.xで動作しない

**対処**: `tr '[:lower:]' '[:upper:]'` に書き換え

**教訓**: macOSはbash 3.2がデフォルト。POSIX互換を意識する。

### MCP/ブラウザ自動化の制限

**問題**: ファイルアップロード（`setInputFiles`相当）がMCPにない場合がある

**対処**: 該当テストはスキップ、履歴で代替確認

**教訓**: 自動化ツールには制限がある。直接Playwright使用も選択肢。

### セッション情報の手動取得

**問題**: Session情報をブラウザDevToolsから手動コピーが必要

**理想**: ログイン操作からCookie/CSRFを自動取得

**今後**: Playwright直接実行で `context.cookies()` 取得を検討

---

## 関連ドキュメント

- [README.md](../README.md) - 使用方法
- [USAGE.md](./USAGE.md) - 詳細な使用方法
- [LESSONS_LEARNED.md](./LESSONS_LEARNED.md) - 実践から学んだ教訓
- [MULTI_AGENT_ORCHESTRATION.md](./MULTI_AGENT_ORCHESTRATION.md) - マルチエージェント構成
