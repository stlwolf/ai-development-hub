# AI駆動検証 - 実践から学んだ教訓

## 概要

本ドキュメントは、AIエージェントとの協調による検証フローを実際に運用した際に得られた教訓をまとめたものです。成功したこと、発生した問題、そしてそこから得られた知見を記録しています。

---

## 実現できたこと

MVP（Minimum Viable Product）として、以下の検証フローを実現しました。

| 目標 | 実現度 | 詳細 |
|------|--------|------|
| JWT認証の自動化 | ✅ 完了 | スクリプトでIdPからトークン取得可能 |
| REST API呼び出しの自動化 | ✅ 完了 | JWT認証/Session認証の両方式に対応 |
| ブラウザ自動操作（MCP） | ⚠️ 部分的 | 基本操作OK、ファイルアップロード等は制限あり |
| エラー監視連携 | ✅ 完了 | Sentry等のAPIでエラーカウント確認可能 |
| 検証ケースの導出 | ✅ 完了 | コード分析→エラー監視→再現手順の導出フロー確立 |
| 自動テスト実行 | ⚠️ 部分的 | CLI操作は自動、一部手動介入が必要 |

### 成功要因

1. **CLIファースト**: AIが直接実行できるシェルスクリプトを用意
2. **認証の分離**: JWT / Session を別スクリプトに分けて複雑さを隔離
3. **ドキュメント化**: 使用方法を即座に文書化し、AIが参照可能に
4. **段階的検証**: API → レスポンス → エラー監視 → UI の順で検証

---

## 発生した問題と対処

### 1. コントローラー初期化と認証のタイミング

**問題**: 
- 認証エラー（401）が返っても、サーバー側でエラーログや警告が発生する
- 認証失敗したはずなのに、何らかの処理が実行されている

**原因**: 
- 多くのWebフレームワーク（Laravel, CakePHP, Express, Django等）では、
  コントローラーの初期化処理（`__construct`, `initialize`, `beforeAction`等）は
  **認証チェックの前に実行される**
- 認証が失敗しても、初期化コードパスは通ってしまう

**教訓**: 
> コントローラーの初期化処理は認証前に実行される。
> 認証失敗しても初期化コードパスは通るため、そこでの警告/エラーは発生しうる。
> 認証前提の処理は初期化ではなくアクション内で行うべき。

---

### 2. 認証方式の複雑さ

**問題**: 
- JWTだけでは一部のAPIで401エラー
- 同一システム内でJWT認証とSession認証が混在

**原因**: 
- モダンなAPIはJWT Bearer Token
- 従来型/内部APIはSession + CSRF Token
- 認証方式がAPIエンドポイントごとに異なる

**対処**: 
- 認証方式ごとにスクリプトを分離（`api_call.sh` / `session_api.sh`）
- どのAPIがどの認証を使うかをドキュメント化

**教訓**: 
> 認証方式はAPI層やエンドポイントごとに異なる可能性がある。事前調査が重要。
> 「全部同じ認証」と思い込まず、401エラーが出たら認証方式を疑う。

---

### 3. bash互換性問題

**問題**: 
- `${1^^}` (大文字変換) がmacOSのbash 3.xで動作しない
- `bad substitution` エラーが発生

**原因**: 
- macOSはbash 3.2がデフォルト（2007年リリース）
- Bash 4.0以降の機能が使えない

**対処**: 
- `tr '[:lower:]' '[:upper:]'` に書き換え
- POSIX互換の構文を使用

**教訓**: 
> macOSのデフォルトbashは古い。シェルスクリプトはPOSIX互換を意識する。
> または、スクリプト冒頭で `#!/usr/bin/env bash` + バージョンチェックを行う。

---

### 4. ブラウザ自動化ツールの制限

**問題**: 
- MCP Browser でファイルアップロード（`setInputFiles`相当）ができない
- 一部のUI操作が自動化できない

**対処**: 
- 該当テストはスキップし、エラー監視の履歴で代替確認
- 重要なテストはPlaywright直接実行を検討

**教訓**: 
> ブラウザ自動化ツール（MCP, Playwright等）には制限がある。
> 制限に遭遇したら、代替手段（API直接呼び出し、履歴確認等）を検討する。
> 全てを自動化しようとせず、コスト対効果で判断する。

---

### 5. コンテキストの消失

**問題**: 
- 長いセッションで「さっき作ったスクリプト」の使い方をAIが忘れる
- 前半で決めた方針が後半で混乱する

**対処**: 
- 即座にドキュメント化（READMEに使用方法を明記）
- 重要な決定事項はファイルに残す

**教訓**: 
> AIは長期記憶を持たない。**ドキュメントがコンテキストの永続化**。
> セッション中の発見 → 即座にドキュメント化 → 次セッションで参照可能

---

### 6. セッション情報の手動取得

**問題**: 
- Session認証に必要な情報（Cookie, CSRF Token）をブラウザDevToolsから手動コピーが必要
- 自動化の途中で人間の介入が発生

**理想**: 
- ログイン操作からCookie/CSRFを自動取得

**対処（暫定）**: 
- 手動取得の手順をドキュメント化
- `.session` ファイルのフォーマットを標準化

**対処（将来）**: 
- Playwright直接実行で `context.cookies()` 取得
- ログインフローを自動化してセッション情報を抽出

**教訓**: 
> Session認証の自動化は難易度が高い。
> 短期的には手動取得を許容し、手順を明確化する。
> 長期的にはPlaywright等でログインフローごと自動化を検討。

---

## 再現性とコンテキスト理解の課題

### 課題1: 暗黙知の明文化

AIは「なぜそうしたか」を覚えていない。

```
❌ 悪い例: "従来型APIは api_call.sh では動かない"

✅ 良い例: "従来型APIはSession認証のため、JWT Bearer Tokenのみの api_call.sh では401。
           session_api.sh を使い、Cookie + X-CSRF-Token を付与する必要がある。"
```

**対策**: ドキュメントに「What」だけでなく「Why」も記録する。

---

### 課題2: テストケース導出の属人性

検証ケースは以下のプロセスで導出されるが、これは属人的：

```
1. PRの修正コードを確認
2. 該当関数が呼ばれるパスを特定
3. エラー監視ツールで実際の発生URLを確認
4. 再現手順を推論
```

**対策**: 検証ケース導出のフレームワーク化

```
Input:  PR番号, 修正ファイル
Process: コード解析 → 呼び出し元特定 → API/URLマッピング → エラー監視検索
Output: 再現手順リスト
```

AIへの指示に上記プロセスを明示的に含めることで、再現性を高める。

---

### 課題3: セッション間の継続性

新しいチャットセッションでは：

- 前回の結論を知らない
- 作成したスクリプトの存在は知っているが使い方を忘れる
- 検証の進捗状況が不明

**対策案**:

1. **STATUS.md**: 進捗状態を記録するファイルを用意
2. **Memory機能**: IDE/AIの記憶機能を活用（Cursor Memory等）
3. **コマンド化**: 検証フローをスクリプト/コマンドとして定義

---

### 課題4: エラー時の自己修復

実際の検証では、エラー発生時に人間が原因を示唆するケースがあった。

```
Human: "これテストデータがないから失敗してるのかも"
AI: (その情報で調査方針を修正)
```

**理想**: AIが自律的に仮説検証サイクルを回す

**現実**: ドメイン知識がないと正しい仮説が立てられない

**対策**:
- よくあるエラーパターンと対処をドキュメント化
- 人間が「ヒント」を与える運用を前提とする
- 将来的にはエラーパターンの学習を検討

---

## 構想 vs 実態

計画段階の構想と、実際に検証した結果の比較。

| 構想 | 実態 | 結論 |
|------|------|------|
| MCP Browserで全UI操作を自動化 | 基本操作OK、一部制限あり | **有効だが補完手段が必要** |
| curlでAPI結果を直接取得 | 認証が複雑（JWT/Session混在） | **スクリプト化で解決** |
| コードから検証対象を自動導出 | コードから「何を叩くか」は導出可能 | **概ね成功** |
| 完全自動化 | 一部手動介入が必要 | **段階的アプローチが現実的** |

---

## 課題の分類

### 普遍的課題（AI開発の本質的限界）

これらは常に付きまとう課題であり、「解決」ではなく「軽減」を目指す。

| 課題 | 内容 | 軽減策 |
|------|------|--------|
| コンテキスト消失 | 長いセッションで情報が薄れる | ドキュメント化、定期的な要約 |
| ドメイン知識の壁 | 「なぜ403か」はAIだけでは判断できない | 人間がヒントを提供、パターン文書化 |
| 自律的仮説検証の限界 | 正しい仮説を立てるには背景知識が必要 | 人間との協調を前提とした設計 |

### プロジェクト固有課題（一度明文化すれば解決）

これらは一度わかれば解決できる課題。

| 課題 | 内容 | 解決策 |
|------|------|--------|
| 認証の複雑さ | JWT/Session混在 | スクリプト化、ドキュメント化 |
| ツール制限 | MCP等の機能制限 | 代替手段のドキュメント化 |
| データ依存 | 特定データがないとテスト不可 | 再現手順・前提条件のドキュメント化 |

**結論**: 固有課題は「一度わかれば解決」、普遍的課題は「運用で軽減」

---

## 今後の改善アイデア

### 短期（すぐにできる）

1. **進捗ファイル（STATUS.md）の導入**: セッション間の継続性を確保
2. **検証フローのコマンド化**: よく使う操作をスクリプト化
3. **エラーパターン集の作成**: よくあるエラーと対処をドキュメント化

### 中期

1. **Playwrightによるログイン自動化**: Session情報の自動取得
2. **OpenAPI/Swaggerからのテストケース自動生成**: API仕様からテストを導出
3. **エラー監視ツールとの深い連携**: アラート→検証の自動トリガー

### 長期

1. **マルチエージェント構成**: API/UI/監視を並列で検証
2. **学習と適応**: 過去の検証結果からパターンを学習
3. **自己修復機能**: エラー時の自動リトライ・代替戦略

---

## チェックリスト：検証セッション開始時

検証を始める前に確認すべき項目：

- [ ] 認証情報は最新か（JWT期限、Session期限）
- [ ] 対象環境は正しいか（URL確認）
- [ ] 前回の検証結果は確認したか（STATUS.md）
- [ ] テストに必要なデータは存在するか
- [ ] エラー監視のベースライン（現在のエラー数）は記録したか

---

## チェックリスト：検証セッション終了時

検証を終える前に行うべきこと：

- [ ] 結果をドキュメント化したか（VERIFICATION_REPORT.md）
- [ ] 発見した問題は記録したか
- [ ] 次回の検証に必要な情報は残したか（STATUS.md更新）
- [ ] 新しく学んだことはLESSONS_LEARNED.mdに追記したか

---

## 関連ドキュメント

- [README.md](../README.md) - 使用方法
- [DESIGN_PRINCIPLES.md](./DESIGN_PRINCIPLES.md) - 設計思想
- [MULTI_AGENT_ORCHESTRATION.md](./MULTI_AGENT_ORCHESTRATION.md) - マルチエージェント構成
- [USAGE.md](./USAGE.md) - 詳細な使用方法
